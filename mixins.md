#### **Название фичи: Mixins**

**Описание**:  
TypeScript, как и многие объектно-ориентированные языки, не позволяет использовать напрямую множественное наследование. Из-за этого, не смотря на то, что можно реализовать множество интерфейсов в классе, унаследовать его можно только от одного класса.  
Функциональность миксинов \(mixins\) частично позволяет унаследовать свойства и методы сразу двух и более классов, тем самым избавившись от дублирования в коде.

**Аналог в Scala**: `mixins`, `traits`

**Решаемая проблема**:  
В какой-то момент в дочерних классах появляется необходимость в одинаковом функционале из-за чего возникает копипаст и нехватка множественного наследования:  
![](/assets/impor666t.png)

Часто данный функционал не имеет ничего общего с родительскими классами, поэтому выносить его в некий базовый класс может быть нелогично.

**Ограничения**:

* Миксин может унаследовать только те свойства и методы, которые непосредственно определены в применяемом классе, то есть он не будет работать, если применяемый класс наследует какие-то свойства / методы от другого класса.

* Если родительские классы определяют метод с одним и тем же именем, то миксин наследует только тот метод, который копируется в него последним в функции applyMixins.

**Плюсы**:

* Простота реализации;
* Легкость переопределения содержащегося в миксине кода;
* Гибкость подключения, возможность создания зависимых миксинов;
* Использование паттерна не усложняет его понимание и поддержку, так как используется существующий механизм наследования;
* Скорость вмешивания — чтобы замешать миксин подобным образом не требуется ни единого цикла;
* Оптимальное использование памяти \(отсутствие копирования\)

**Как решить проблему**:

Создание временного класса на основе миксина и подстановка его в очередь наследования:

![](/assets/imp43rt.png)

**Синтаксис**[**:**](https://citifox.ru/event/adidas-dance-battle/)

```js

```

**Перекомпилированный в JSкод:**

```js

```

**Больше деталей**: [тут](https://habrahabr.ru/post/255865/)

